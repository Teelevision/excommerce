/*
 * ExCommerce
 *
 * ExCommerce is an example commerce system.
 *
 * API version: beta
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"unicode/utf8"

	"github.com/Teelevision/excommerce/authentication"
	"github.com/Teelevision/excommerce/controller"
	"github.com/Teelevision/excommerce/model"
	"github.com/gorilla/mux"
	"github.com/pariz/gountries"
)

var _ Router = (*OrdersAPI)(nil)

// A OrdersAPI binds http requests to an api service and writes the service results to the http response
type OrdersAPI struct {
	Authenticator     *authentication.Authenticator
	OrderController   *controller.Order
	CartController    *controller.Cart
	ProductController *controller.Product
}

// Routes returns all of the api route for the OrdersApiController
func (c *OrdersAPI) Routes() Routes {
	return Routes{
		{
			Name:        "CreateOrderFromCart",
			Method:      "POST",
			Path:        "/beta/carts/{cartId}/prepareOrder",
			HandlerFunc: c.Authenticator.HandlerFunc(c.CreateOrderFromCart),
		},
		{
			Name:        "PlaceOrder",
			Method:      "POST",
			Path:        "/beta/orders/{orderId}/place",
			HandlerFunc: c.Authenticator.HandlerFunc(c.PlaceOrder),
		},
	}
}

// CreateOrderFromCart - Create order from cart
func (c *OrdersAPI) CreateOrderFromCart(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// validation
	params := mux.Vars(r)
	cartID := params["cartId"]
	if !uuidPattern.Match([]byte(cartID)) {
		invalidInput("The cartId of the path is not a UUID.", uuidPattern.String(), w)
		return
	}
	input := &Order{}
	if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
		invalidJSON(err, w)
		return
	}
	// convert coupons to lower case
	for i, code := range input.Coupons {
		input.Coupons[i] = strings.ToLower(code)
	}
	for _, s := range []struct {
		target  string
		address Address
	}{
		{"buyer", input.Buyer},
		{"recipient", input.Recipient},
	} {
		target, address := s.target, s.address
		if l := utf8.RuneCountInString(address.Name); l < 1 || l > 1000 {
			failValidation(fmt.Sprintf("The %s's name must be 1 to 1000 characters long.", target),
				fmt.Sprintf("/%s/name", target), w)
			return
		}
		if address.Country == "" {
			failValidation(fmt.Sprintf("The %s's country must be given.", target),
				fmt.Sprintf("/%s/country", target), w)
			return
		}
		if len(address.Country) != 2 {
			failValidation(fmt.Sprintf("The %s's country must be a 2 letter country code (ISO 3166-1).", target),
				fmt.Sprintf("/%s/country", target), w)
			return
		}
		if _, err := gountries.New().FindCountryByAlpha(address.Country); err != nil {
			failValidation(fmt.Sprintf("The %s's country code %q is unknown.", target, address.Country),
				fmt.Sprintf("/%s/country", target), w)
			return
		}
		if l := utf8.RuneCountInString(address.PostalCode); l < 1 || l > 10 {
			failValidation(fmt.Sprintf("The %s's postal code must be 1 to 10 characters long.", target),
				fmt.Sprintf("/%s/postalCode", target), w)
			return
		}
		if l := utf8.RuneCountInString(address.City); l < 1 || l > 1000 {
			failValidation(fmt.Sprintf("The %s's city must be 1 to 1000 characters long.", target),
				fmt.Sprintf("/%s/city", target), w)
			return
		}
		if l := utf8.RuneCountInString(address.Street); l < 1 || l > 1000 {
			failValidation(fmt.Sprintf("The %s's street must be 1 to 1000 characters long.", target),
				fmt.Sprintf("/%s/street", target), w)
			return
		}
	}
	uniqueCoupons := make(map[string]interface{}, len(input.Coupons))
	for i, code := range input.Coupons {
		if _, exists := uniqueCoupons[code]; exists {
			failValidation(fmt.Sprintf("The coupon %q cannot be used twice.", code),
				fmt.Sprintf("/coupons/%d", i), w)
			return
		}
		uniqueCoupons[code] = nil
	}

	// convert to internal model
	orderInput := model.Order{
		CartID:    cartID,
		Buyer:     model.Address(input.Buyer),
		Recipient: model.Address(input.Recipient),
		Coupons:   make([]*model.Coupon, len(input.Coupons)),
	}
	// load cart
	cart, err := c.CartController.Get(ctx, cartID)
	switch {
	case errors.Is(err, controller.ErrForbidden):
		w.WriteHeader(http.StatusForbidden) // 403
		return
	case errors.Is(err, controller.ErrNotFound):
		w.WriteHeader(http.StatusNotFound) // 404
		return
	case errors.Is(err, controller.ErrDeleted):
		w.WriteHeader(http.StatusGone) // 410
		return
	case errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):
		w.WriteHeader(499) // client closed request
		return
	case err == nil && cart.Locked:
		w.WriteHeader(http.StatusLocked) // 423
		return
	case err == nil:
		orderInput.Cart = cart
	default:
		panic(err)
	}
	// load coupons
	for i, code := range input.Coupons {
		coupon, err := c.ProductController.GetCoupon(ctx, code)
		switch {
		case errors.Is(err, controller.ErrNotFound):
			failValidation(fmt.Sprintf("The coupon %q is incorrect or expired.", code),
				fmt.Sprintf("/coupons/%d", i), w)
			return
		case errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):
			w.WriteHeader(499) // client closed request
			return
		case err == nil:
			orderInput.Coupons[i] = coupon
		default:
			panic(err)
		}
	}

	// action
	order, err := c.OrderController.CreateAndGet(ctx, &orderInput)
	switch {
	case errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):
		w.WriteHeader(499) // client closed request
	case err == nil:
		EncodeJSONResponse(convertOrderOut(order, "valid"), nil, w)
	default:
		panic(err)
	}
}

// PlaceOrder - Place order
func (c *OrdersAPI) PlaceOrder(w http.ResponseWriter, r *http.Request) {
	// validation
	params := mux.Vars(r)
	orderID := params["orderId"]
	if !uuidPattern.Match([]byte(orderID)) {
		invalidInput("The orderId of the path is not a UUID.", uuidPattern.String(), w)
		return
	}

	// action
	order, err := c.OrderController.Place(r.Context(), orderID)
	switch {
	case errors.Is(err, controller.ErrForbidden):
		w.WriteHeader(http.StatusForbidden) // 403
	case errors.Is(err, controller.ErrNotFound):
		w.WriteHeader(http.StatusNotFound) // 404
	case errors.Is(err, controller.ErrDeleted):
		w.WriteHeader(http.StatusGone) // 410
	case errors.Is(err, controller.ErrLocked):
		w.WriteHeader(http.StatusLocked) // 423
	case errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):
		w.WriteHeader(499) // client closed request
	case err == nil:
		EncodeJSONResponse(convertOrderOut(order, "placed"), nil, w)
	default:
		panic(err)
	}
}

func convertOrderOut(order *model.Order, status string) *Order {
	out := Order{
		ID:        order.ID,
		Status:    status,
		Price:     float32(order.Price) / 100,
		Buyer:     Address(order.Buyer),
		Recipient: Address(order.Recipient),
		Coupons:   make([]string, len(order.Coupons)),
		Positions: convertPositionsOut(order.Positions),
	}
	for i, coupon := range order.Coupons {
		out.Coupons[i] = coupon.Code
	}
	return &out
}
